<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>argagg: Argument Aggregator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">argagg
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Argument Aggregator </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is the Doxygen documentation for Argument Aggregator, a simple C++11 argument parser.</p>
<p>To use just create an <a class="el" href="structargagg_1_1parser.html" title="A list of option definitions used to inform how to parse arguments. ">argagg::parser</a> object. However, the struct doesn't provide any explicit methods for defining flags. Instead we define the flags using initialization lists. </p><pre class="fragment">argagg::parser argparser {{
    { "help", {"-h", "--help"},
      "shows this help message", 0},
    { "delim", {"-d", "--delim"},
      "delimiter (default: ,)", 1},
    { "num", {"-n", "--num"},
      "number", 1},
  }};
</pre><p>An option is specified by four things: the name of the option, the strings that activate the option (flags), the option's help message, and the number of arguments the option expects.</p>
<p>With the parser defined you actually parse the arguments by calling the <a class="el" href="structargagg_1_1parser.html#a4f85341056c6f30e02c58b0c9b33dedb" title="Parses the provided command line arguments and returns the results as parser_results. ">argagg::parser::parse()</a> method. If there are any problems then either an <a class="el" href="structargagg_1_1option__lacks__argument__error.html" title="This exception is thrown when an option requires an argument but is not provided one. This can happen if another flag was found after the option or if we simply reach the end of the command line arguments. ">argagg::option_lacks_argument_error</a> or <a class="el" href="structargagg_1_1unexpected__option__error.html" title="This exception is thrown when an option is parsed unexpectedly such as when an argument was expected ...">argagg::unexpected_option_error</a> exception are thrown. </p><pre class="fragment">argagg::parser_results args;
try {
  args = argparser.parse(argc, argv);
} catch (const std::exception&amp; e) {
  std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
  return EXIT_FAILURE;
}
</pre><p>You can check if an option shows up in the command line arguments by accessing the option by name from the parser results and using the implicit boolean conversion. You can write out a simplistic option help message by streaming the <a class="el" href="structargagg_1_1parser.html" title="A list of option definitions used to inform how to parse arguments. ">argagg::parser</a> instance itself. </p><pre class="fragment">if (args["help"]) {
  std::cerr &lt;&lt; argparser;
  //     -h, --help
  //         shows this help message
  //     -d, --delim
  //         delimiter (default: ,)
  //     -n, --num
  //         number
  return EXIT_SUCCESS;
}
</pre><p>That help message is only for the flags. If you want a usage message it's up to you to provide it. </p><pre class="fragment">if (args["help"]) {
  std::cerr &lt;&lt; "Usage: program [options] ARG1 ARG2" &lt;&lt; std::endl
            &lt;&lt; argparser;
  // Usage: program [options] ARG1 ARG2
  //     -h, --help
  //         shows this help message
  //     -d, --delim
  //         delimiter (default: ,)
  //     -n, --num
  //         number
  return EXIT_SUCCESS;
}
</pre><p>Generally argagg tries to do a minimal amount of work to leave most of the control with the user.</p>
<p>If you want to get an option argument but fallback on a default value if it doesn't exist then you can use the <a class="el" href="structargagg_1_1option__results.html#a9a51160f3a6d84e162e5ec909a2ed44a" title="Converts the argument parsed for the LAST option parse result for the parent definition to the provid...">argagg::option_results::as()</a> API and provide a default value. </p><pre class="fragment">auto delim = args["delim"].as&lt;std::string&gt;(",");
</pre><p>If you don't mind being implicit an implicit conversion operator is provided allowing you to write simple assignments. </p><pre class="fragment">int x = 0;
if (args["num"]) {
  x = args["num"];
}
</pre><p>Finally, you can get all of the positional arguments as an <a class="elRef" doxygen="/home/vnguyen/projects/argagg/doc/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html" title="STL class. ">std::vector</a> using the <a class="el" href="structargagg_1_1parser__results.html#a159b7d39369d6a3bc76bb484a109d6cc" title="Vector of positional arguments. ">argagg::parser_results::pos</a> member. You can alternatively convert individual positional arguments using the same conversion functions as the option argument conversion methods. </p><pre class="fragment">auto y = 0.0;
if (args.pos.size() &gt; 0) {
  y = args.as&lt;double&gt;(0);
}
</pre><p>One can also specify <code>--</code> on the command line in order to treat all following arguments as not options.</p>
<p>For a more detailed treatment take a look at the examples or test cases.</p>
<h2>Mental Model </h2>
<p>The parser just returns a structure of pointers to the C-strings in the original <code>argv</code> array. The <a class="el" href="structargagg_1_1parser.html#a4f85341056c6f30e02c58b0c9b33dedb">argagg::parser::parse()</a> method returns a <a class="el" href="structargagg_1_1parser__results.html">argagg::parser_results</a> object which has two things: position arguments and option results. The position arguments are just a <a class="elRef" doxygen="/home/vnguyen/projects/argagg/doc/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> of <code>const char*</code>. The option results are a mapping from option name (<a class="elRef" doxygen="/home/vnguyen/projects/argagg/doc/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>) to <a class="el" href="structargagg_1_1option__results.html">argagg::option_results</a> objects. The <a class="el" href="structargagg_1_1option__results.html">argagg::option_results</a> objects are just an <a class="elRef" doxygen="/home/vnguyen/projects/argagg/doc/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> of <a class="el" href="structargagg_1_1option__result.html">argagg::option_result</a> objects. Each instance of an <a class="el" href="structargagg_1_1option__result.html">argagg::option_result</a> represents the option showing up on the command line. If there was an argument associated with it then the <a class="el" href="structargagg_1_1option__result.html#a10cf3c02b1c5e5d57f6b9f41b622da46">argagg::option_result::arg</a> member will <em>not</em> be <code>nullptr</code>.</p>
<p>Consider the following command: </p><pre class="fragment">gcc -g -I/usr/local/include -I. -o test main.o foo.o -L/usr/local/lib -lz bar.o -lpng
</pre><p>This would produce a structure like follows, written in psuedo-YAML, where each string is actually a <code>const char*</code> pointing to some part of a string in the original <code>argv</code> array: </p><pre class="fragment">parser_results:
  program: "gcc"
  pos: ["main.o", "foo.o", "bar.o"]
  options:
    version:
    debug:
      all:
      - arg: null
    include_path:
      all:
      - arg: "/usr/local/include"
      - arg: "."
    library_path:
      all:
      - arg: "/usr/local/lib"
    library:
      all:
      - arg: "z"
      - arg: "png"
    output:
      all:
      - arg: "test"
</pre><p>Conversion to types occurs at the very end when the <code>as&lt;T&gt;()</code> API is used. Up to that point <code>argagg</code> is just dealing with C-strings.</p>
<h2>Installation </h2>
<p>There is just a single header file (<code><a class="el" href="argagg_8hpp.html">argagg.hpp</a></code>) so you can copy that whereever you want. If you want to properly install it you can use the CMake script. The CMake script exists primarily to build the tests and documentation, but an install target for the header is provided.</p>
<p>The standard installation dance using CMake and <code>make</code> is as follows: </p><pre class="fragment">mkdir build
cd build
cmake -DCMAKE_INSTALL_PREFIX=/usr/local ..
make install
ctest -V # optionally run tests
</pre><p>Override <a href="https://cmake.org/cmake/help/v2.8.12/cmake.html#variable:CMAKE_INSTALL_PREFIX"><code>CMAKE_INSTALL_PREFIX</code></a> to change the installation location. By default (on UNIX variants) it will install to <code>/usr/local</code> resulting in the header being copied to <code>/usr/local/include/argagg/argagg.hpp</code>.</p>
<p>If you have <a href="http://www.stack.nl/~dimitri/doxygen/">Doxygen</a> it should build and install documentation as well.</p>
<p>There are no dependencies other than the standard library.</p>
<h2>Edge Cases </h2>
<p>There are some interesting edge cases that show up in option parsing. I used the behavior of <code>gcc</code> as my target reference in these cases.</p>
<h3>Greedy Arguments</h3>
<p>Remember that options that require arguments will greedily process arguments.</p>
<p>Say we have the following options: <code>-a</code>, <code>-b</code>, <code>-c</code>, and <code>-o</code>. They all don't accept arguments except <code>-o</code>. Below is a list of permutations for short flag grouping and the results:</p>
<ul>
<li><code>-abco foo</code>: <code>-o</code>'s argument is <code>foo</code></li>
<li><code>-aboc foo</code>: <code>-o</code>'s argument is <code>c</code>, <code>foo</code> is a positional argument</li>
<li><code>-aobc foo</code>: <code>-o</code>'s argument is <code>bc</code>, <code>foo</code> is a positional argument</li>
<li><code>-oabc foo</code>: <code>-o</code>'s argument is <code>abc</code>, <code>foo</code> is a positional argument</li>
</ul>
<p>For whitespace delimited arguments the greedy processing means the next argument element (in <code>argv</code>) will be treated as an argument for the previous option, regardless of whether or not it looks like a flag or some other special entry. That means you get behavior like below:</p>
<ul>
<li><code>--output=foo -- --bar</code>: <code>--output</code>'s argument is <code>foo</code>, <code>--bar</code> is a positional argument</li>
<li><code>--output -- --bar</code>: <code>--output</code>'s argument is <code>--</code>, <code>--bar</code> is treated as a flag</li>
<li><code>--output --bar</code>: <code>--output</code>'s argument is <code>--bar</code> </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
